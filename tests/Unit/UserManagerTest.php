<?php

namespace RoleManager\Tests\Unit;

use PHPUnit\Framework\TestCase;
use RoleManager\UserManager;
use RoleManager\LoggerInterface;
use PDO;
use PDOStatement;
use Exception;

/**
 * Unit tests for the UserManager class.
 *
 * These tests do not interact with a real database. Instead, they use mock objects
 * to isolate the UserManager class and verify its internal logic.
 */
class UserManagerTest extends TestCase
{
    private $pdoMock;
    private $loggerMock;
    private $stmtMock;

    protected function setUp(): void
    {
        // Create mock objects for the dependencies before each test
        $this->pdoMock = $this->createMock(PDO::class);
        $this->loggerMock = $this->createMock(LoggerInterface::class);
        $this->stmtMock = $this->createMock(PDOStatement::class);
    }

    public function testCreateUserFailsIfLoginIsEmpty()
    {
        // 1. We expect an exception to be thrown for invalid input.
        $this->expectException(Exception::class);
        $this->expectExceptionMessage("Login is required");

        // 2. We assert that the database is NEVER touched if validation fails.
        $this->pdoMock->expects($this->never())->method('prepare');

        // 3. Instantiate UserManager with our mocks.
        $userManager = new UserManager($this->pdoMock, $this->loggerMock);

        // 4. Call the method with invalid data to trigger the exception.
        $userManager->create('', 'password', 'email@test.com');
    }

    public function testCreateUserSuccessfullyHashesPasswordAndSavesToDb()
    {
        // 1. Configure the PDO mock to expect a 'prepare' call and return our statement mock.
        $this->pdoMock->expects($this->once())
            ->method('prepare')
            ->with($this->stringContains('INSERT INTO role_manager_users'))
            ->willReturn($this->stmtMock);

        // 2. Configure the statement mock to expect an 'execute' call.
        // We use a callback to inspect the arguments passed to execute().
        $this->stmtMock->expects($this->once())
            ->method('execute')
            ->with($this->callback(function ($params) { // This callback checks the parameters
                // Check that all necessary parameters are present
                $this->assertCount(5, $params);
                $this->assertEquals('testuser', $params[0]);
                $this->assertEquals('test@email.com', $params[2]);
                
                // IMPORTANT: Check that the password is NOT the plain text 'password123'
                $this->assertNotEquals('password123', $params[1]);
                // Check that the hash is a valid hash generated by password_verify
                $this->assertTrue(password_verify('password123', $params[1]));
                
                return true;
            }))
            ->willReturn(true); // This tells the mock to return true, simulating success.
            
        // 3. Configure the PDO mock to return a fake ID on lastInsertId().
        $this->pdoMock->expects($this->once())
            ->method('lastInsertId')
            ->willReturn('123');

        // 4. Instantiate UserManager with our mocks.
        $userManager = new UserManager($this->pdoMock, $this->loggerMock);
        
        // 5. Call the method with valid data.
        $userId = $userManager->create('testuser', 'password123', 'test@email.com', 'John', 'Doe');

        // 6. Assert that the returned user ID is the one we faked.
        $this->assertEquals('123', $userId);
    }
}